---
title: "Simulation"
format: html
---

```{r}
library(lavaan)
library(cubature)
library(mvtnorm)
```


# Data Import
```{r}
tag = "2D"

load(paste("param_", tag, ".RData", sep = ""))

A = read.csv(paste("A_", tag, ".csv", sep = ""), header = FALSE)
Z = read.csv(paste("Z_", tag, ".csv", sep = ""), header = FALSE)
Y = read.csv(paste("Y_", tag, ".csv", sep = ""), header = FALSE)
```

# True CATE and ATE
```{r}
psi_inv = solve(psi)
H_covar_inv = solve(H_covar)
lambda_psi = t(lambda) %*% psi_inv

z = rep(1,p)

M = lambda_psi %*% lambda + H_covar_inv
d = lambda_psi %*% (z-Z_intercept)
M_inv = solve(M)

CATE.true = C1 %*% solve(M) %*% d + C0

ATE.true = C0
```


# Comparison Methods

## Nieve Estimate
```{r}
A1 = which(A == 1)
A0 = which(A == 0)

Y1 = mean(unlist(Y$V1[A1]))
Y0 = mean(unlist(Y$V1[A0]))

nieve.ATE = Y1-Y0
```


## Linear Regression
```{r}
AZY = Z
AZY$A = unlist(A)
AZY$Y = unlist(Y)

m1 = lm(Y~.,AZY)

linear.ATE = m1$coefficients["A"]
```

## IPW
```{r}
p = dim(Z)[2]

AZ = Z
AZ$A = A$V1

m1 = glm(formula = A ~ ., family = binomial(link = "logit"), data = AZ)
x = predict(m1, newdata = Z, type="response")

EY1 = mean(unlist(A*Y/x))

EY0 = mean(unlist((1-A)*Y/(1-x)))

IPW.ATE = EY1-EY0
```

## Matching
```{r}
z.mat = as.matrix(Z)

A1_indices = which(A==1)
A0_indices = which(A==0)

total.diff1 = 0

for (i in A1_indices){
  diffs = wordspace::rowNorms(sweep(z.mat[A0_indices,], 2, z.mat[i,]))
  match = which.min(diffs)
  total.diff1 = total.diff1 + Y[i,] - Y[A0_indices[match],]
}

est1 = total.diff1 / length(A1_indices)

total.diff2 = 0

for (i in A0_indices){
  diffs = wordspace::rowNorms(sweep(z.mat[A1_indices,], 2, z.mat[i,]))
  match = which.min(diffs)
  total.diff2 = total.diff2 - Y[i,] + Y[A1_indices[match],]
}

est2 = total.diff2 / length(A0_indices)

matching.ATE = (total.diff1 + total.diff2) / length(A$V1)
```

# Our Estimate
```{r}
model <- '
efa("efa1")*h1 =~ V1+V2+V3
A ~ h1
A | 0*t1
A ~ 1

h1 ~ 0*1
'
model <- '
efa("efa1")*h1 + efa("efa1")*h2 =~ V1+V2+V3+V4+V5+V6
A ~ h1 + h2
A | 0*t1
A ~ 1

h1 ~ 0*1
h2 ~ 0*1
'

p=6
k=2

mydata = Z
mydata$A = ordered(A$V1, levels = c(0, 1))

fit <- sem(model, data=mydata, ordered = "A")
lambda.est = inspect(fit,what="est")$lambda[1:p,1:k]
psi.est = inspect(fit,what="est")$theta[1:p,1:p]
sigma.est = inspect(fit,what="est")$psi[1:k,1:k]
b.est = inspect(fit,what="est")$beta[k+1,1:k]
nu.est = inspect(fit,what="est")$nu[1:p,1]
c.est = inspect(fit,what="est")$alpha[k+1]

mydata$A <- as.numeric(as.character(mydata$A))

M.est = t(lambda.est) %*% solve(psi.est) %*% lambda.est + solve(sigma.est)
M.inv.est = solve(M.est)
uCDF.generate = function(M.inv.est, d.est, b, c){
  uCDF = function(u){
    return(u*c(pnorm(u%*%b+c))*dmvnorm(u, M.inv.est%*%d.est, matrix(M.inv.est, nrow = k)))
  }
  return(uCDF)
}

psi.est.inv = solve(psi.est)
constant.denom = sqrt(t(b.est)%*%M.inv.est%*%b.est+1)

expectations = matrix(, nrow = nrow(mydata), ncol = k)
for(i in 1:nrow(mydata)){
    z <- mydata[i,1:p]
    a <- mydata[i,p+1]
    d.est = t(lambda.est) %*% psi.est.inv %*% (t(z - nu.est))
    meanF = uCDF.generate(M.inv.est, d.est, b.est, c.est)
    inner.constant = (t(b.est)%*%M.inv.est%*%d.est+c.est)/constant.denom
    constant = c(a/pnorm(inner.constant) + (1-a)/(1-pnorm(inner.constant)))
    expectations[i,] = constant*cubintegrate(meanF, rep(-Inf,k), rep(Inf,k), fDim=k)$integral
}

df = data.frame(expectations)
df$Y = Y$V1
df$A = ordered(A$V1, levels = c(0, 1))
reg = lm(Y ~ A*expectations, df)

betas = coef(reg)

linearCATE = function(z, coefs, lambda, psi, sigma.est, nu){
  k = sqrt(length(sigma.est))
  d = t(lambda) %*% solve(psi) %*% (z - nu)
  M = t(lambda) %*% solve(psi) %*% lambda + solve(sigma.est)
  lower.index = 3+k
  higher.index = 2+2*k
  return(c(coefs[lower.index:higher.index])%*%solve(M)%*%d + coefs[2])
}

ATE.est = 0
errors = c()
for(i in 1:length(A$V1)){
  z = Z[i,]
  cate = linearCATE(t(z), betas, lambda.est, psi.est, sigma.est, nu.est)
  ATE.est = ATE.est + cate
  
  M.true = lambda_psi %*% lambda + H_covar_inv
  d.true = lambda_psi %*% (t(z)-Z_intercept)
  M_inv.true = solve(M.true)
  
  CATE.true = C1 %*% M_inv.true %*% d.true + C0
  errors[i] = abs(cate-CATE.true)
}
ATE.est = ATE.est/length(A$V1)
```

# Comparisons

|Method|Estimate|Error|
|:-:|:-:|:-:|
|Nieve|`r nieve.ATE`|`r nieve.ATE-ATE.true`|
|Linear|`r linear.ATE`|`r linear.ATE-ATE.true`|
|Matching|`r matching.ATE`|`r matching.ATE-ATE.true`|
|IPW|`r IPW.ATE`|`r IPW.ATE-ATE.true`|
|Ours|`r ATE.est`|`r ATE.est-ATE.true`|
