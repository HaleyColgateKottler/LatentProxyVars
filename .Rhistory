dataGen(1, 3, 3, .5, 10000, -.3, c(.2, -.1, .6), 0, c(1), c(.9), .6, c(.8), c(-.2), tag)
for (i in 1:100){
print(i)
azGen(tag)
k=1
p=3
rawData = dataImport(tag)
ATE.true = trueATE(tag)
nieve.ATE = nieveEst(rawData)
nieve[i] = abs(ATE.true - nieve.ATE)
linear.ATE = linearEst(rawData)
linear[i] = abs(ATE.true - linear.ATE)
IPW.ATE = IPWest(rawData)
IPW.errors[i] = abs(ATE.true - IPW.ATE)
IPW.est[i] = IPW.ATE
matching.ATE = matchingEst(rawData)
match[i] = abs(ATE.true - matching.ATE)
model = '
efa("efa1")*h1 + efa("efa1")*h2 =~ V1+V2+V3+V4+V5+V6
A ~ h1 + h2
A | 0*t1
A ~ 1
h1 ~ 0*1
h2 ~ 0*1
'
model <- '
efa("efa1")*h1 =~ V1+V2+V3
A ~ h1
A | 0*t1
A ~ 1
h1 ~ 0*1
'
params = fitUZA(model, rawData, k, p)
# load(paste("param_", tag, ".RData", sep = ""))
# params = list(
#   lambda.est = lambda,
#   psi.est = psi,
#   sigma.est = H_covar,
#   b.est = B,
#   nu.est = Z_intercept,
#   c.est = A_intercept
# )
expected.df = fitExpectations(params, rawData, k, p, 1)
AZ = subset(rawData, select = -c(Y))
Z = subset(AZ, select = -c(A))
yModel = '
Y ~ .*.
'
betas = fitMeanModel(yModel, subset(expected.df, select = c(Y, A, expectations1)))
ATEest = ATE.est(expected.df, params, betas)
latent.est[i] = ATEest
latent.errors[i] = abs(ATEest-ATE.true)
if (i %% 10 == 0){
errs.df = data.frame(latent.est, latent.errors, IPW.est, IPW.errors, linear, match, nieve)
write.table(errs.df, file = paste("errors_", tag, ".csv", sep = ""), sep = ",")
}
}
for (i in 1:100){
print(i)
azGen(tag)
k=1
p=3
rawData = dataImport(tag)
ATE.true = trueATE(tag)
nieve.ATE = nieveEst(rawData)
nieve[i] = abs(ATE.true - nieve.ATE)
linear.ATE = linearEst(rawData)
linear[i] = abs(ATE.true - linear.ATE)
IPW.ATE = IPWest(rawData)
IPW.errors[i] = abs(ATE.true - IPW.ATE)
IPW.est[i] = IPW.ATE
matching.ATE = matchingEst(rawData)
match[i] = abs(ATE.true - matching.ATE)
model = '
efa("efa1")*h1 + efa("efa1")*h2 =~ V1+V2+V3+V4+V5+V6
A ~ h1 + h2
A | 0*t1
A ~ 1
h1 ~ 0*1
h2 ~ 0*1
'
model <- '
efa("efa1")*h1 =~ V1+V2+V3
A ~ h1
A | 0*t1
A ~ 1
h1 ~ 0*1
'
params = fitUZA(model, rawData, k, p)
# load(paste("param_", tag, ".RData", sep = ""))
# params = list(
#   lambda.est = lambda,
#   psi.est = psi,
#   sigma.est = H_covar,
#   b.est = B,
#   nu.est = Z_intercept,
#   c.est = A_intercept
# )
expected.df = fitExpectations(params, rawData, k, p, 1)
AZ = subset(rawData, select = -c(Y))
Z = subset(AZ, select = -c(A))
yModel = '
Y ~ .*.
'
betas = fitMeanModel(yModel, subset(expected.df, select = c(Y, A, expectations1)))
ATEest = ATE.est(expected.df, params, betas)
latent.est[i] = ATEest
latent.errors[i] = abs(ATEest-ATE.true)
if (i %% 10 == 0){
errs.df = data.frame(latent.est, latent.errors, IPW.est, IPW.errors, linear, match, nieve)
write.table(errs.df, file = paste("errors_", tag, ".csv", sep = ""), sep = ",")
}
}
# 2Da run of 50 trials with 1000 samples in 2D and ours majorly beats IPW
dataGen(1, 3, 3, .5, 1000, -.3, c(.2, -.1, .6), 0, c(1), c(.9), .6, c(.8), c(-.2), tag)
for (i in 1:100){
print(i)
azGen(tag)
k=1
p=3
rawData = dataImport(tag)
ATE.true = trueATE(tag)
nieve.ATE = nieveEst(rawData)
nieve[i] = abs(ATE.true - nieve.ATE)
linear.ATE = linearEst(rawData)
linear[i] = abs(ATE.true - linear.ATE)
IPW.ATE = IPWest(rawData)
IPW.errors[i] = abs(ATE.true - IPW.ATE)
IPW.est[i] = IPW.ATE
matching.ATE = matchingEst(rawData)
match[i] = abs(ATE.true - matching.ATE)
model = '
efa("efa1")*h1 + efa("efa1")*h2 =~ V1+V2+V3+V4+V5+V6
A ~ h1 + h2
A | 0*t1
A ~ 1
h1 ~ 0*1
h2 ~ 0*1
'
model <- '
efa("efa1")*h1 =~ V1+V2+V3
A ~ h1
A | 0*t1
A ~ 1
h1 ~ 0*1
'
params = fitUZA(model, rawData, k, p)
# load(paste("param_", tag, ".RData", sep = ""))
# params = list(
#   lambda.est = lambda,
#   psi.est = psi,
#   sigma.est = H_covar,
#   b.est = B,
#   nu.est = Z_intercept,
#   c.est = A_intercept
# )
expected.df = fitExpectations(params, rawData, k, p, 1)
AZ = subset(rawData, select = -c(Y))
Z = subset(AZ, select = -c(A))
yModel = '
Y ~ .*.
'
betas = fitMeanModel(yModel, subset(expected.df, select = c(Y, A, expectations1)))
ATEest = ATE.est(expected.df, params, betas)
latent.est[i] = ATEest
latent.errors[i] = abs(ATEest-ATE.true)
if (i %% 10 == 0){
errs.df = data.frame(latent.est, latent.errors, IPW.est, IPW.errors, linear, match, nieve)
write.table(errs.df, file = paste("errors_", tag, ".csv", sep = ""), sep = ",")
}
}
library(lavaan)
library(cubature)
library(mvtnorm)
library(dplyr)
source("datagen.R")
source("computeTrue.R")
source("comparisonMethods.R")
source("latentMethod.R")
dataImport = function(tag){
A = read.csv(paste("A_", tag, ".csv", sep = ""), header = FALSE)
Z = read.csv(paste("Z_", tag, ".csv", sep = ""), header = FALSE)
Y = read.csv(paste("Y_", tag, ".csv", sep = ""), header = FALSE)
c
df = Z
df$A = A$V1
df$Y = Y$V1
return(df)
}
CATE.errors = function(df, params, betas, tag){
errors = c()
Z = subset(df, select = -c(A, Y))
for(i in 1:nrow(df)){
z = Z[i,]
cate = linearCATE(t(z), betas, params)
cate.true = trueCATE(tag, z)
errors[i] = cate-cate.true
}
return(errors)
}
latent.errors = c()
latent.est = c()
nieve = c()
IPW.est = c()
IPW.errors = c()
match = c()
linear = c()
tag = "1Dbreak"
# 2Da run of 50 trials with 1000 samples in 2D and ours majorly beats IPW
dataGen(1, 3, 3, .5, 1000, -.3, c(.2, -.1, .6), 0, c(1), c(.9), .6, c(.8), c(-.2), tag)
for (i in 1:100){
print(i)
azGen(tag)
k=1
p=3
rawData = dataImport(tag)
ATE.true = trueATE(tag)
nieve.ATE = nieveEst(rawData)
nieve[i] = abs(ATE.true - nieve.ATE)
linear.ATE = linearEst(rawData)
linear[i] = abs(ATE.true - linear.ATE)
IPW.ATE = IPWest(rawData)
IPW.errors[i] = abs(ATE.true - IPW.ATE)
IPW.est[i] = IPW.ATE
matching.ATE = matchingEst(rawData)
match[i] = abs(ATE.true - matching.ATE)
model = '
efa("efa1")*h1 + efa("efa1")*h2 =~ V1+V2+V3+V4+V5+V6
A ~ h1 + h2
A | 0*t1
A ~ 1
h1 ~ 0*1
h2 ~ 0*1
'
model <- '
efa("efa1")*h1 =~ V1+V2+V3
A ~ h1
A | 0*t1
A ~ 1
h1 ~ 0*1
'
params = fitUZA(model, rawData, k, p)
# load(paste("param_", tag, ".RData", sep = ""))
# params = list(
#   lambda.est = lambda,
#   psi.est = psi,
#   sigma.est = H_covar,
#   b.est = B,
#   nu.est = Z_intercept,
#   c.est = A_intercept
# )
expected.df = fitExpectations(params, rawData, k, p, 1)
AZ = subset(rawData, select = -c(Y))
Z = subset(AZ, select = -c(A))
yModel = '
Y ~ .*.
'
betas = fitMeanModel(yModel, subset(expected.df, select = c(Y, A, expectations1)))
ATEest = ATE.est(expected.df, params, betas)
latent.est[i] = ATEest
latent.errors[i] = abs(ATEest-ATE.true)
if (i %% 10 == 0){
errs.df = data.frame(latent.est, latent.errors, IPW.est, IPW.errors, linear, match, nieve)
write.table(errs.df, file = paste("errors_", tag, ".csv", sep = ""), sep = ",")
}
}
errs.df = data.frame(latent.est, latent.errors, IPW.est, IPW.errors, linear, match, nieve)
write.table(errs.df, file = paste("errors_", tag, ".csv", sep = ""), sep = ",")
hist(latent.errors-IPW.errors)
mean(latent.errors)
mean(IPW.errors)
mean(linear)
mean(match)
mean(nieve)
mean(latent.errors)
mean(IPW.errors)
sigmaSim = function(k, p, communality){
# p number of variables
# k number of factors
# communality 1 low, 2 wide, 3 high
p = p + 1
A = matrix(0, p, k)
# need row entries to sum to k-1
A[,1] = sample(0:(k-1), p, replace = TRUE)
for (i in 1:p){
if (k-2<1) break
for (j in 2:(k-2)){
current_sum = sum(A[i,])
if (current_sum == k-1){
A[i,j] = 0
} else {
A[i,j] = sample(0:(k-1-current_sum), 1, replace = TRUE)
}
}
}
A[,k] = (k-1)*matrix(1,1,p) - rowSums(A)
# Add normal deviation
c = .1*sample(7:9, k)
x = rnorm(p*k)
x1 = matrix(x, nrow = p)
d = c(matrix(1,ncol=p, nrow = 1)/wordspace::rowNorms(x1))
Y = A*c + d*x1*sqrt(1-c**2)
# Apply skewing function
Y2 = Y + abs(Y) + 0.2
Y3 = abs(Y) + 0.2
Z = (1.2/2.2) * (Y*Y2) / Y3
g = rep(1,p)/wordspace::rowNorms(Z)
# Scale to set communality
if (communality == 1){
B1 = diag(.1*sample(2:4, p, replace=TRUE), p)
} else if (communality == 2){
B1 = diag(.1*sample(2:8, p, replace=TRUE), p)
} else if (communality == 3){
B1 = diag(.1*sample(6:8, p, replace=TRUE), p)
} else {
B1 = matrix(0,p,p)
}
B2 = diag(p) - B1
# Final factor loading matrix
lambda = c(sqrt(B1)%*%g)*Z
psi = sqrt(B2)
sigma = lambda%*%t(lambda) + psi%*%t(psi)
return(list(sigma, lambda, psi))
}
saveParams = function(k, p, communality, var_Y, A_intercept, Z_intercept, Y_intercept, H_covar, C0, C1, tag){
output = sigmaSim(k, p, communality)
sigma = output[[1]]
lambda = output[[2]]
psi = output[[3]]
save(k, p, communality, var_Y, sigma, lambda, psi, H_covar, C0, C1, A_intercept, Z_intercept, Y_intercept, file = paste("param_", tag, ".RData", sep = ""))
}
azGen = function(tag, n){
load(paste("param_", tag, ".RData", sep = ""))
H_set = matrix(, nrow = n, ncol = k)
Z_set = matrix(, nrow = n, ncol = p)
A_set = c()
Y_set = c()
for (i in 1:n){
epsilon_Z = MASS::mvrnorm(n = 1, mu = rep(0,p), Sigma = psi)
epsilon_A = rnorm(1, mean = 0, sd = 1)
epsilon_Y = rnorm(1, mean = 0, sd = sqrt(var_Y))
H = MASS::mvrnorm(n=1, mu = rep(0,k), Sigma = H_covar)
ZA = lambda %*% H
Z = ZA[1:p] + Z_intercept + epsilon_Z
A = ZA[p+1] + A_intercept + epsilon_A
Y = (C1 %*% H) + C0 * A + Y_intercept + epsilon_Y
H_set[i,] = t(H)
Z_set[i,] = Z
A_set[i] = A
Y_set[i] = Y
}
write.table(H_set, file = file.path("Data", paste("H_", tag, ".csv", sep = "")), row.names = FALSE, col.names = FALSE, sep = ",")
write.table(Z_set, file = file.path("Data", paste("Z_", tag, ".csv", sep = "")), row.names = FALSE, col.names = FALSE, sep = ",")
write.table(A_set, file = file.path("Data", paste("A_", tag, ".csv", sep = "")), row.names = FALSE, col.names = FALSE, sep = ",")
write.table(Y_set, file = file.path("Data", paste("Y_", tag, ".csv", sep = "")), row.names = FALSE, col.names = FALSE, sep = ",")
}
#dataGen(1, 3, 3, .5,1000, -.3, c(.2, -.1, .6), 0, c(1), c(.9), .6, c(.8), c(-.2), tag)
dataGen = function(k, p, communality, var_Y, n, A_intercept, Z_intercept, Y_intercept, H_covar, C0, C1, tag){
saveParams(k, p, communality, var_Y, A_intercept, Z_intercept, Y_intercept, H_covar, C0, C1, tag)
azGen(tag, n)
}
dataGen(2, 6, 2, .5, 1000, .3, c(.5,.25, .3, -.1, -.2, .4), 2, matrix(c(1,.5,.5,1), nrow = 2, byrow = TRUE), 2, c(4,1), "2D")
azGen = function(tag, n){
load(paste("param_", tag, ".RData", sep = ""))
H_set = matrix(, nrow = n, ncol = k)
Z_set = matrix(, nrow = n, ncol = p)
A_set = c()
Y_set = c()
for (i in 1:n){
epsilon_Z = MASS::mvrnorm(n = 1, mu = rep(0,p+1), Sigma = psi)
epsilon_A = rnorm(1, mean = 0, sd = 1)
epsilon_Y = rnorm(1, mean = 0, sd = sqrt(var_Y))
H = MASS::mvrnorm(n=1, mu = rep(0,k), Sigma = H_covar)
ZA = lambda %*% H
Z = ZA[1:p] + Z_intercept + epsilon_Z
A = ZA[p+1] + A_intercept + epsilon_A
Y = (C1 %*% H) + C0 * A + Y_intercept + epsilon_Y
H_set[i,] = t(H)
Z_set[i,] = Z
A_set[i] = A
Y_set[i] = Y
}
write.table(H_set, file = file.path("Data", paste("H_", tag, ".csv", sep = "")), row.names = FALSE, col.names = FALSE, sep = ",")
write.table(Z_set, file = file.path("Data", paste("Z_", tag, ".csv", sep = "")), row.names = FALSE, col.names = FALSE, sep = ",")
write.table(A_set, file = file.path("Data", paste("A_", tag, ".csv", sep = "")), row.names = FALSE, col.names = FALSE, sep = ",")
write.table(Y_set, file = file.path("Data", paste("Y_", tag, ".csv", sep = "")), row.names = FALSE, col.names = FALSE, sep = ",")
}
#dataGen(1, 3, 3, .5,1000, -.3, c(.2, -.1, .6), 0, c(1), c(.9), .6, c(.8), c(-.2), tag)
dataGen = function(k, p, communality, var_Y, n, A_intercept, Z_intercept, Y_intercept, H_covar, C0, C1, tag){
saveParams(k, p, communality, var_Y, A_intercept, Z_intercept, Y_intercept, H_covar, C0, C1, tag)
azGen(tag, n)
}
dataGen(2, 6, 2, .5, 1000, .3, c(.5,.25, .3, -.1, -.2, .4), 2, matrix(c(1,.5,.5,1), nrow = 2, byrow = TRUE), 2, c(4,1), "2D")
debugSource("~/Documents/research/ProxyVariables/LatentProxyVars/datagen2.R")
debugSource("~/Documents/research/ProxyVariables/LatentProxyVars/datagen2.R")
sigmaSim = function(k, p, communality){
# p number of variables
# k number of factors
# communality 1 low, 2 wide, 3 high
p = p + 1
A = matrix(0, p, k)
# need row entries to sum to k-1
A[,1] = sample(0:(k-1), p, replace = TRUE)
for (i in 1:p){
if (k-2<1) break
for (j in 2:(k-2)){
current_sum = sum(A[i,])
if (current_sum == k-1){
A[i,j] = 0
} else {
A[i,j] = sample(0:(k-1-current_sum), 1, replace = TRUE)
}
}
}
A[,k] = (k-1)*matrix(1,1,p) - rowSums(A)
# Add normal deviation
c = .1*sample(7:9, k)
x = rnorm(p*k)
x1 = matrix(x, nrow = p)
d = c(matrix(1,ncol=p, nrow = 1)/wordspace::rowNorms(x1))
Y = A*c + d*x1*sqrt(1-c**2)
# Apply skewing function
Y2 = Y + abs(Y) + 0.2
Y3 = abs(Y) + 0.2
Z = (1.2/2.2) * (Y*Y2) / Y3
g = rep(1,p)/wordspace::rowNorms(Z)
# Scale to set communality
if (communality == 1){
B1 = diag(.1*sample(2:4, p, replace=TRUE), p)
} else if (communality == 2){
B1 = diag(.1*sample(2:8, p, replace=TRUE), p)
} else if (communality == 3){
B1 = diag(.1*sample(6:8, p, replace=TRUE), p)
} else {
B1 = matrix(0,p,p)
}
B2 = diag(p) - B1
# Final factor loading matrix
lambda = c(sqrt(B1)%*%g)*Z
psi = sqrt(B2)
sigma = lambda%*%t(lambda) + psi%*%t(psi)
return(list(sigma, lambda, psi))
}
saveParams = function(k, p, communality, var_Y, A_intercept, Z_intercept, Y_intercept, H_covar, C0, C1, tag){
output = sigmaSim(k, p, communality)
sigma = output[[1]]
lambda = output[[2]]
psi = output[[3]]
save(k, p, communality, var_Y, sigma, lambda, psi, H_covar, C0, C1, A_intercept, Z_intercept, Y_intercept, file = paste("param_", tag, ".RData", sep = ""))
}
azGen = function(tag, n){
load(paste("param_", tag, ".RData", sep = ""))
H_set = matrix(, nrow = n, ncol = k)
Z_set = matrix(, nrow = n, ncol = p)
A_set = c()
Y_set = c()
for (i in 1:n){
epsilon_AZ = MASS::mvrnorm(n = 1, mu = rep(0,p+1), Sigma = psi)
epsilon_Z = epsilon_AZ[1:p]
epsilon_A = epsilon_AZ[p+1]
epsilon_Y = rnorm(1, mean = 0, sd = sqrt(var_Y))
H = MASS::mvrnorm(n=1, mu = rep(0,k), Sigma = H_covar)
ZA = lambda %*% H
Z = ZA[1:p,1] + Z_intercept + epsilon_Z
A = ZA[p+1,1] + A_intercept + epsilon_A
Y = (C1 %*% H) + C0 * A + Y_intercept + epsilon_Y
H_set[i,] = t(H)
Z_set[i,] = Z
A_set[i] = A
Y_set[i] = Y
}
write.table(H_set, file = file.path("Data", paste("H_", tag, ".csv", sep = "")), row.names = FALSE, col.names = FALSE, sep = ",")
write.table(Z_set, file = file.path("Data", paste("Z_", tag, ".csv", sep = "")), row.names = FALSE, col.names = FALSE, sep = ",")
write.table(A_set, file = file.path("Data", paste("A_", tag, ".csv", sep = "")), row.names = FALSE, col.names = FALSE, sep = ",")
write.table(Y_set, file = file.path("Data", paste("Y_", tag, ".csv", sep = "")), row.names = FALSE, col.names = FALSE, sep = ",")
}
#dataGen(1, 3, 3, .5,1000, -.3, c(.2, -.1, .6), 0, c(1), c(.9), .6, c(.8), c(-.2), tag)
dataGen = function(k, p, communality, var_Y, n, A_intercept, Z_intercept, Y_intercept, H_covar, C0, C1, tag){
saveParams(k, p, communality, var_Y, A_intercept, Z_intercept, Y_intercept, H_covar, C0, C1, tag)
azGen(tag, n)
}
dataGen(2, 6, 2, .5, 1000, .3, c(.5,.25, .3, -.1, -.2, .4), 2, matrix(c(1,.5,.5,1), nrow = 2, byrow = TRUE), 2, c(4,1), "2D")
dataGen(1, 6, 3, .25, 500, -.2, c(.2, -.1, .4), 2, c(1), -.7, c(-.2), "1D")
library(lavaan)
library(cubature)
library(mvtnorm)
library(dplyr)
source("datagen2.R")
source("computeTrue.R")
source("comparisonMethods.R")
source("latentMethod.R")
dataImport = function(tag){
A = read.csv(file.path("Data", paste("A_", tag, ".csv", sep = "")), header = FALSE)
Z = read.csv(file.path("Data", paste("Z_", tag, ".csv", sep = "")), header = FALSE)
Y = read.csv(file.path("Data", paste("Y_", tag, ".csv", sep = "")), header = FALSE)
c
df = Z
df$A = A$V1
df$Y = Y$V1
return(df)
}
CATE.errors = function(df, params, betas, tag){
errors = c()
Z = subset(df, select = -c(A, Y))
for(i in 1:nrow(df)){
z = Z[i,]
cate = linearCATE(t(z), betas, params)
cate.true = trueCATE(tag, z)
errors[i] = cate-cate.true
}
return(errors)
}
