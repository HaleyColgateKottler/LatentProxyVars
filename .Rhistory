"psi" = diag(psi),
"phi" = diag(2),
"alpha" = C1,
"gamma" = c(-3, -2))
constraints = matrix(1, nrow = p, ncol = k)
calcSE <- function(data, constraints, EM_output){
n = nrow(data)
p = nrow(constraints)
k = ncol(constraints)
lambda.parms = sum(constraints==1)
theta.EM = as.numeric(c(
EM_output$mu,
EM_output$lambda[constraints==1],
EM_output$psi,
EM_output$alpha,
EM_output$gamma
))
# estimating function
# if weights are supplied, then it uses REM estimating equations; otherwise uses EM estimating equations
estFUN <- function(data, constraints){
mu = apply(data[,1:p], 2, mean)
n = nrow(data)
p = ncol(data) - 1
k = ncol(constraints)
lambda = matrix(0, nrow = p, ncol = k)
lambda.idx = which(constraints==1)
lambda.parms = length(lambda.idx)
d.lambda = matrix(0, nrow = n, ncol = lambda.parms)
d.psi = matrix(0, nrow = n, ncol = p)
d.alpha = matrix(0, nrow = n, ncol = k)
d.gamma = matrix(0, nrow = n, ncol = k)
function(theta){
mu = theta[1:p]
lambda.est = theta[(p+1):(p+lambda.parms)]
lambda[lambda.idx] <- lambda.est
psi = theta[(p+lambda.parms+1):(p+lambda.parms+p)]
alpha = theta[(2*p+lambda.parms+1):(2*p+lambda.parms+k)]
gamma = theta[(2*p+lambda.parms+k+1):(2*p+lambda.parms+2*k)]
# estimating equations
Z = apply(data[,1:p], 1, function(y) y - mu)
sigma = lambda %*% t(lambda) + diag(psi)
inv.sigma = solve(sigma)
m = t(lambda) %*% solve(diag(psi)) %*% lambda + diag(k)
f.base = solve(m)%*%t(lambda)%*%solve(diag(psi))
d.mu = t(inv.sigma %*% Z)
for (i in 1:n){
D = inv.sigma %*% (diag(p) - (Z[,i] %*% t(Z[,i]) %*% inv.sigma))
d.lambda[i,] = -(D %*% lambda)[lambda.idx]
d.psi[i,] = -0.5 * diag(D)
f = f.base%*%Z[,i]
d.alpha[i,] = 2*(data[i,p+1] - (alpha+gamma*data[i,p-1])%*%f) %*% t(f)
d.gamma[i,] = data[i,p]*2*(data[i,p+1] - (alpha+gamma*data[i,p])%*%f) %*% t(f)
}
# score function for each person and parameter
c(d.mu, d.lambda, d.psi, d.alpha, d.gamma)
}
}
# use geex package to estimate standard errors
m.results.EM <- geex::m_estimate(
estFUN = estFUN,
data = data,
roots = theta.EM,
compute_roots = FALSE,
outer_args = list(constraints = constraints))
se = sqrt(diag(geex::vcov(m.results.EM)))
names(se) <- c(paste0('mu', 1:p),
paste0('lambda', which(constraints==1)),
paste0('psi', 1:p),
paste0('alpha', 1:k),
paste0('gamma', 1:k)
)
return(se)
}
se.est = calcSE(raw.data, constraints, EM_output)
data.import <- function(tag, n) {
A <- read.csv(
file.path(
"Data", "Samples",
paste("A_", tag, "_", n, ".csv", sep = "")
),
header = FALSE
)
Z <- read.csv(
file.path(
"Data", "Samples",
paste("Z_", tag, "_", n, ".csv", sep = "")
),
header = FALSE
)
Y <- read.csv(
file.path(
"Data", "Samples",
paste("Y_", tag, "_", n, ".csv", sep = "")
),
header = FALSE
)
df <- Z
df$A <- A$V1
df$Y <- Y$V1
return(df)
}
data.import <- function(tag, n) {
A <- read.csv(
file.path(
"Data", "Samples",
paste("A_", tag, "_", n, ".csv", sep = "")
),
header = FALSE
)
Z <- read.csv(
file.path(
"Data", "Samples",
paste("Z_", tag, "_", n, ".csv", sep = "")
),
header = FALSE
)
Y <- read.csv(
file.path(
"Data", "Samples",
paste("Y_", tag, "_", n, ".csv", sep = "")
),
header = FALSE
)
df <- Z
df$A <- A$V1
df$Y <- Y$V1
return(df)
}
tag = "2D"
load(file.path("Data", "Parameters", paste("param_", tag, ".RData", sep = "")))
raw.data = data.import(tag, 500)
EM_output = list("mu" = c(Z_intercept, A_intercept),
"lambda" = lambda,
"psi" = diag(psi),
"phi" = diag(2),
"alpha" = C1,
"gamma" = c(-3, -2))
constraints = matrix(1, nrow = p, ncol = k)
calcSE <- function(data, constraints, EM_output){
n = nrow(data)
p = nrow(constraints)
k = ncol(constraints)
lambda.parms = sum(constraints==1)
theta.EM = as.numeric(c(
EM_output$mu,
EM_output$lambda[constraints==1],
EM_output$psi,
EM_output$alpha,
EM_output$gamma
))
# estimating function
# if weights are supplied, then it uses REM estimating equations; otherwise uses EM estimating equations
estFUN <- function(data, constraints){
mu = apply(data[,1:p], 2, mean)
n = nrow(data)
p = ncol(data) - 1
k = ncol(constraints)
lambda = matrix(0, nrow = p, ncol = k)
lambda.idx = which(constraints==1)
lambda.parms = length(lambda.idx)
d.lambda = matrix(0, nrow = n, ncol = lambda.parms)
d.psi = matrix(0, nrow = n, ncol = p)
d.alpha = matrix(0, nrow = n, ncol = k)
d.gamma = matrix(0, nrow = n, ncol = k)
function(theta){
mu = theta[1:p]
lambda.est = theta[(p+1):(p+lambda.parms)]
lambda[lambda.idx] <- lambda.est
psi = theta[(p+lambda.parms+1):(p+lambda.parms+p)]
alpha = theta[(2*p+lambda.parms+1):(2*p+lambda.parms+k)]
gamma = theta[(2*p+lambda.parms+k+1):(2*p+lambda.parms+2*k)]
# estimating equations
Z = apply(data[,1:p], 1, function(y) y - mu)
sigma = lambda %*% t(lambda) + diag(psi)
inv.sigma = solve(sigma)
m = t(lambda) %*% solve(diag(psi)) %*% lambda + diag(k)
f.base = solve(m)%*%t(lambda)%*%solve(diag(psi))
d.mu = t(inv.sigma %*% Z)
for (i in 1:n){
D = inv.sigma %*% (diag(p) - (Z[,i] %*% t(Z[,i]) %*% inv.sigma))
d.lambda[i,] = -(D %*% lambda)[lambda.idx]
d.psi[i,] = -0.5 * diag(D)
f = f.base%*%Z[,i]
d.alpha[i,] = 2*(data[i,p+1] - (alpha+gamma*data[i,p-1])%*%f) %*% t(f)
d.gamma[i,] = data[i,p]*2*(data[i,p+1] - (alpha+gamma*data[i,p])%*%f) %*% t(f)
}
# score function for each person and parameter
c(d.mu, d.lambda, d.psi, d.alpha, d.gamma)
}
}
# use geex package to estimate standard errors
m.results.EM <- geex::m_estimate(
estFUN = estFUN,
data = data,
roots = theta.EM,
compute_roots = FALSE,
outer_args = list(constraints = constraints))
se = sqrt(diag(geex::vcov(m.results.EM)))
names(se) <- c(paste0('mu', 1:p),
paste0('lambda', which(constraints==1)),
paste0('psi', 1:p),
paste0('alpha', 1:k),
paste0('gamma', 1:k)
)
return(se)
}
se.est = calcSE(raw.data, constraints, EM_output)
n = nrow(data)
data = raw.data
n = nrow(data)
p = nrow(constraints)
constraints = matrix(1, nrow = p+1, ncol = k)
calcSE <- function(data, constraints, EM_output){
n = nrow(data)
p = nrow(constraints)
k = ncol(constraints)
lambda.parms = sum(constraints==1)
theta.EM = as.numeric(c(
EM_output$mu,
EM_output$lambda[constraints==1],
EM_output$psi,
EM_output$alpha,
EM_output$gamma
))
# estimating function
# if weights are supplied, then it uses REM estimating equations; otherwise uses EM estimating equations
estFUN <- function(data, constraints){
mu = apply(data[,1:p], 2, mean)
n = nrow(data)
p = ncol(data) - 1
k = ncol(constraints)
lambda = matrix(0, nrow = p, ncol = k)
lambda.idx = which(constraints==1)
lambda.parms = length(lambda.idx)
d.lambda = matrix(0, nrow = n, ncol = lambda.parms)
d.psi = matrix(0, nrow = n, ncol = p)
d.alpha = matrix(0, nrow = n, ncol = k)
d.gamma = matrix(0, nrow = n, ncol = k)
function(theta){
mu = theta[1:p]
lambda.est = theta[(p+1):(p+lambda.parms)]
lambda[lambda.idx] <- lambda.est
psi = theta[(p+lambda.parms+1):(p+lambda.parms+p)]
alpha = theta[(2*p+lambda.parms+1):(2*p+lambda.parms+k)]
gamma = theta[(2*p+lambda.parms+k+1):(2*p+lambda.parms+2*k)]
# estimating equations
Z = apply(data[,1:p], 1, function(y) y - mu)
sigma = lambda %*% t(lambda) + diag(psi)
inv.sigma = solve(sigma)
m = t(lambda) %*% solve(diag(psi)) %*% lambda + diag(k)
f.base = solve(m)%*%t(lambda)%*%solve(diag(psi))
d.mu = t(inv.sigma %*% Z)
for (i in 1:n){
D = inv.sigma %*% (diag(p) - (Z[,i] %*% t(Z[,i]) %*% inv.sigma))
d.lambda[i,] = -(D %*% lambda)[lambda.idx]
d.psi[i,] = -0.5 * diag(D)
f = f.base%*%Z[,i]
d.alpha[i,] = 2*(data[i,p+1] - (alpha+gamma*data[i,p-1])%*%f) %*% t(f)
d.gamma[i,] = data[i,p]*2*(data[i,p+1] - (alpha+gamma*data[i,p])%*%f) %*% t(f)
}
# score function for each person and parameter
c(d.mu, d.lambda, d.psi, d.alpha, d.gamma)
}
}
# use geex package to estimate standard errors
m.results.EM <- geex::m_estimate(
estFUN = estFUN,
data = data,
roots = theta.EM,
compute_roots = FALSE,
outer_args = list(constraints = constraints))
se = sqrt(diag(geex::vcov(m.results.EM)))
names(se) <- c(paste0('mu', 1:p),
paste0('lambda', which(constraints==1)),
paste0('psi', 1:p),
paste0('alpha', 1:k),
paste0('gamma', 1:k)
)
return(se)
}
se.est = calcSE(raw.data, constraints, EM_output)
se.est
library(lavaan)
library(cubature)
library(mvtnorm)
library(dplyr)
library(reshape2)
library(ggplot2)
source("datagen2.R")
for (sample.size in 1:10){
azGen(tag, sample.size * 100)
raw.data = data.import(tag, sample.size * 100)
EM_output = list("mu" = c(Z_intercept, A_intercept),
"lambda" = lambda,
"psi" = diag(psi),
"phi" = diag(2),
"alpha" = C1,
"gamma" = c(-3, -2))
se.est = calcSE(raw.data, constraints, EM_output)
se.est
}
for (sample.size in 1:10){
azGen(tag, sample.size * 100)
raw.data = data.import(tag, sample.size * 100)
EM_output = list("mu" = c(Z_intercept, A_intercept),
"lambda" = lambda,
"psi" = diag(psi),
"phi" = diag(2),
"alpha" = C1,
"gamma" = c(-3, -2))
se.est = calcSE(raw.data, constraints, EM_output)
print(se.est[1])
}
for (sample.size in 1:10){
azGen(tag, sample.size * 100)
raw.data = data.import(tag, sample.size * 100)
EM_output = list("mu" = c(Z_intercept, A_intercept),
"lambda" = lambda,
"psi" = diag(psi),
"phi" = diag(2),
"alpha" = C1,
"gamma" = c(-3, -2))
se.est = calcSE(raw.data, constraints, EM_output)
ests[sample.size,] = se.est
}
ests = matrix(0, nrow = 10, ncol = 32)
for (sample.size in 1:10){
azGen(tag, sample.size * 100)
raw.data = data.import(tag, sample.size * 100)
EM_output = list("mu" = c(Z_intercept, A_intercept),
"lambda" = lambda,
"psi" = diag(psi),
"phi" = diag(2),
"alpha" = C1,
"gamma" = c(-3, -2))
se.est = calcSE(raw.data, constraints, EM_output)
ests[sample.size,] = se.est
}
plot(ests[,1])
plot(ests[,2])
plot(ests[,3])
plot(ests[,4])
plot(ests[,5])
plot(ests[,6])
plot(ests[,7])
df = melt(ests)
View(df)
ggplot(df) + facet_grid(Var2 ~ .)
ggplot(df) + facet_wrap(Var2 ~ .)
ggplot(df, x = Var1, y = value) + facet_wrap(Var2 ~ .)
ggplot(df, aes(x = Var1, y = value, color = Var2)) + geom_line()
ggplot(df, aes(x = Var1, y = value, color = Var2)) + geom_line(group=Var2)
ggplot(df, aes(x = Var1, y = value, group = Var2)) + geom_line()
ests = matrix(0, nrow = 10, ncol = 32)
for (sample.size in 1:10){
azGen(tag, sample.size * 100)
raw.data = data.import(tag, sample.size * 100)
EM_output = list("mu" = c(Z_intercept, A_intercept),
"lambda" = lambda,
"psi" = diag(psi),
"phi" = diag(2),
"alpha" = C1,
"gamma" = c(-3, -2))
se.est = calcSE(raw.data, constraints, EM_output)
ests[sample.size,] = se.est
}
df = melt(ests)
ggplot(df, aes(x = Var1, y = value, group = Var2)) + geom_line()
ggplot(df, aes(x = Var1, y = value, group = Var2, color = Var2)) + geom_line()
df$Var1 = factor(df$Var1)
ggplot(df, aes(x = Var1, y = value, group = Var2, color = Var2)) + geom_line()
df = melt(ests[,29:32])
df$Var1 = factor(df$Var1)
ggplot(df, aes(x = Var1, y = value, group = Var2, color = Var2)) + geom_line()
ests = matrix(0, nrow = 10, ncol = 32)
for (sample.size in 1:10){
azGen(tag, sample.size * 1000)
raw.data = data.import(tag, sample.size * 1000)
EM_output = list("mu" = c(Z_intercept, A_intercept),
"lambda" = lambda,
"psi" = diag(psi),
"phi" = diag(2),
"alpha" = C1,
"gamma" = c(-3, -2))
se.est = calcSE(raw.data, constraints, EM_output)
ests[sample.size,] = se.est
}
df = melt(ests[,29:32])
df$Var1 = factor(df$Var1)
ggplot(df, aes(x = Var1, y = value, group = Var2, color = Var2)) + geom_line()
library(lavaan)
library(cubature)
library(mvtnorm)
library(dplyr)
library(reshape2)
library(ggplot2)
source("computeTrue.R")
source("comparisonMethods2.R")
source("latentMethod2.R")
savemarker <- 50
k <- 1
p <- 3
tag <- "IV_multiplicative"
for (sample.size in 0:4) {
sample.size <- 200 + 200 * sample.size
est.df <- data.frame(matrix(nrow = 0, ncol = 3))
colnames(est.df) <- c("latent", "linear", "IPW")
set.seed <- 17
latent <- c()
ipw <- c()
linear <- c()
iv <- c()
for (j in 1:100) {
i <- j %% savemarker + 1
U <- rnorm(sample.size)
Z <- rmvnorm(sample.size, mean = c(.5, .7, -.8))
A <- -.9*U *( c(.1, -.7, .4) %*% t(Z)) - 1 + .4*rnorm(sample.size)
Y <- -.8 * U + .5 * A + .2 + rnorm(sample.size)
raw.data <- data.frame('Z' = Z, 'A' = A, 'Y' = Y)
colnames(raw.data) <- c("V1", "V2", "V3", "A", "Y")
ate.true <- .5
linear.ate <- linearEst(raw.data)
linear[i] <- linear.ate
ipw.ate <- IPWest(raw.data)
ipw[i] <- ipw.ate
iv.ate <- IVest(raw.data)
iv[i] <- iv.ate
ate.est <- latent.ATE(raw.data, k, p)
latent[i] <- ate.est
if (j %% savemarker == 0) {
print(sample.size)
print(j)
est.df <- rbind(est.df, cbind(latent, linear, ipw, iv))
write.table(est.df,
file.path(
"Data", "Estimates",
paste("ests_", tag, as.character(sample.size),
"_IVtrial.csv",
sep = ""
)
),
sep = ",",
row.names = FALSE
)
latent <- c()
ipw <- c()
linear <- c()
iv <- c()
}
}
}
library(lavaan)
library(cubature)
library(mvtnorm)
library(dplyr)
library(reshape2)
library(ggplot2)
source("computeTrue.R")
source("comparisonMethods2.R")
source("latentMethod2.R")
savemarker <- 50
k <- 1
p <- 3
tag <- "IV_multiplicative"
for (sample.size in 0:4) {
sample.size <- 200 + 200 * sample.size
est.df <- data.frame(matrix(nrow = 0, ncol = 3))
colnames(est.df) <- c("latent", "linear", "IPW")
set.seed <- 17
latent <- c()
ipw <- c()
linear <- c()
iv <- c()
for (j in 1:100) {
i <- j %% savemarker + 1
U <- rnorm(sample.size)
Z <- rmvnorm(sample.size, mean = c(.5, .7, -.8))
A <- -.9*U *( c(.1, -.7, .4) %*% t(Z)) - 1 + .4*rnorm(sample.size)
Y <- -.8 * U + .5 * A + .2 + rnorm(sample.size)
raw.data <- data.frame('Z' = Z, 'A' = A, 'Y' = Y)
colnames(raw.data) <- c("V1", "V2", "V3", "A", "Y")
ate.true <- .5
linear.ate <- linearEst(raw.data)
linear[i] <- linear.ate
ipw.ate <- IPWest(raw.data)
ipw[i] <- ipw.ate
iv.ate <- IVest(raw.data)
iv[i] <- iv.ate
ate.est <- latent.ATE(raw.data, k, p)
latent[i] <- ate.est
if (j %% savemarker == 0) {
print(sample.size)
print(j)
est.df <- rbind(est.df, cbind(latent, linear, ipw, iv))
write.table(est.df,
file.path(
"Data", "Estimates",
paste("ests_", tag, as.character(sample.size),
"_IVtrial.csv",
sep = ""
)
),
sep = ",",
row.names = FALSE
)
latent <- c()
ipw <- c()
linear <- c()
iv <- c()
}
}
}
