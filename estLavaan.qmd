---
title: "est lavaan"
format: html
---

```{r}
library(lavaan)
library(cubature)
library(mvtnorm)
```

```{r}
tag = "1D"
```

read data
```{r}
# Load data
# mydata <- read.csv("mydata.csv")
A = read.csv(paste("A_", tag, ".csv", sep = ""), header = FALSE)
Z = read.csv(paste("Z_", tag, ".csv", sep = ""), header = FALSE)
Y = read.csv(paste("Y_", tag, ".csv", sep = ""), header = FALSE)
p = length(Z[1,])
k=1

mydata = Z
mydata$A = ordered(A$V1, levels = c(0, 1))
```

parameter recovery for factor probit model
```{r}
# Specify factor-probit regression model
model <- '
efa("efa1")*h1 + efa("efa1")*h2 =~ V1 + V2 + V3 + V4 + V5 + V6

A ~ h1 + h2

A | 0*t1
A ~ 1

h1 + h2 ~ 0*1
'

model <- '
efa("efa1")*h1 =~ V1+V2+V3
A ~ h1
A | 0*t1
A ~ 1

h1 ~ 0*1
'
k=1
p=3
fit <- sem(model, data=mydata, ordered = "A")
summary(fit, standardized=TRUE)
inspect(fit,what="est")$lambda
lambda.est = inspect(fit,what="est")$lambda[1:p,1:k]
lambda.est
inspect(fit,what="est")$theta
psi.est = inspect(fit,what="est")$theta[1:p,1:p]
psi.est
inspect(fit,what="est")$psi
sigma.est = inspect(fit,what="est")$psi[1:k,1:k]
sigma.est
inspect(fit,what="est")$beta
b.est = inspect(fit,what="est")$beta[k+1,1:k]
b.est
inspect(fit,what="est")$nu
nu.est = inspect(fit,what="est")$nu[1:p,1]
nu.est
inspect(fit,what="est")$alpha
c.est = inspect(fit,what="est")$alpha[k+1]
c.est
```

expectations for functions of H given Z
```{r}
meanH = function(za, lambda, psi, sigma.est, b, alpha, nu){

  a = za[length(za)][1]
  z = t(za[1:length(za)-1])
  
  d = t(lambda) %*% solve(psi) %*% (z  - nu)
  M = t(lambda) %*% solve(psi) %*% lambda + 1/sigma.est
  constant1 = (b*d+M*alpha)/sqrt(M*(M+b^2))
  constant2 = b/sqrt(b^2*M+M^2)
  
  if (a == 1){
    return((constant2 * dnorm(constant1))/(pnorm(constant1))+d/M)
  }else if(a == 0){
    return((1/(1-pnorm(constant1)))*(constant2*dnorm(constant1)+d*pnorm(constant1)/M))
  }
}

# meanH(mydata[1,], lambda.est, psi.est, sigma.est, alpha.est[2], b.est)

varianceH = function(za, lambda, psi, sigma.est, nu, b, alpha){
  a = za[length(za)][1]
  z = t(za[1:length(za)-1])
  d = t(lambda) %*% solve(psi) %*% (z - nu)
  M = t(lambda) %*% solve(psi) %*% lambda + 1/sigma.est
  constant1 = (b*d+M*alpha)/sqrt(M*(M+b^2))
  constant2 = b/sqrt(b^2*M+M^2)
  
  if (a==1){
    ratio = dnorm(constant1)/pnorm(constant1)
    return(1/M-constant2*(constant1*ratio+ratio^2))
  }else if (a==0){
    Gx = pnorm(constant1)
    G.x = dnorm(constant1)
    difG.x = pnorm(constant1, lower.tail=FALSE)
    ratio = constant2^2
    return((1/difG.x^2)*((M+d^2)*Gx/M^2 + (b^3*d+2*b*d*M-alpha*b^2*M)*G.x/((b^2*M+M^2)^(3/2)) - ratio*G.x^2-(M+2*d^2)*Gx^2/M^2 - (3*b^3*d+4*b*d*M-b^2*alpha*M)*Gx*G.x/((b^2*M+M^2)^(3/2))))
  }
}
```

```{r}
mydata$A <- as.numeric(as.character(mydata$A))

M = t(lambda.est) %*% solve(psi.est) %*% lambda.est + solve(sigma.est)
M.inv = solve(M)
d = t(lambda.est) %*% solve(psi.est) %*% (rep(1,p) - nu.est)
M.inv%*%d
uCDF.generate = function(M.inv, d, b, c){
  uCDF = function(u){
    return(u*c(pnorm(u%*%b+c))*dmvnorm(u, M.inv%*%d, matrix(M.inv, nrow = k)))
  }
  return(uCDF)
}

meanF = uCDF.generate(M.inv, d, b.est, c.est)

expectations2 = matrix(, nrow=nrow(mydata), ncol = k)
expectations = matrix(, nrow = nrow(mydata), ncol = k)
for(i in 1:nrow(mydata)){
    z <- mydata[i,1:p]
    a <- mydata[i,p+1]
    d = t(lambda.est) %*% solve(psi.est) %*% (t(z - nu.est))
    meanF = uCDF.generate(M.inv, d, b.est, c.est)
    inner.constant = (t(b.est)%*%M.inv%*%d+c.est)/sqrt(t(b.est)%*%M.inv%*%b.est+1)
    constant = c(a/pnorm(inner.constant) + (1-a)/(1-pnorm(inner.constant)))
    expectations[i,] = constant*cubintegrate(meanF, rep(-Inf,k), rep(Inf,k), fDim=k)$integral
    row = mydata[i,]
    expectations2[i,] = meanH(row, lambda.est, psi.est, sigma.est, b.est, c.est, nu.est)
}

df = data.frame(expectations)
df$ef2 = data.frame(expectations2)
```


regression for betas

```{r}
variances = c()

for(i in 1:nrow(mydata)) {
    row <- mydata[i,]
    variances[i] = varianceH(row, lambda.est, psi.est, sigma.est, nu.est, b.est, alpha.est[2])
}

mydata[c('E1')] = expectations
mydata$Y = Y$V1
reg = lm(Y ~ A*E1, mydata)
summary.lm(reg)

betas = coef(reg)
betas
expectations
```

```{r}
linearCATE = function(z, coefs, lambda, psi, sigma.est, nu){
  d = t(lambda) %*% solve(psi) %*% (z - nu)
  M = t(lambda) %*% solve(psi) %*% lambda + solve(sigma.est)
  return(c(coefs[4])%*%solve(M)%*%d + coefs[2])
}

linearCATE(rep(1,p), betas, lambda.est, psi.est, sigma.est, nu.est)
```

```{r}
mydata$variances = variances
mydata$expectations.2 = variances + expectations^2

reg2 = lm(Y ~ A*expectations+A*expectations.2, mydata)
summary.lm(reg2)

betas = coef(reg2)

quadCATE = function(z, coefs, lambda, psi, sigma.est, nu){
  d = t(lambda) %*% solve(psi) %*% (z - nu)
  M = t(lambda) %*% solve(psi) %*% lambda + 1/sigma.est
  
  return(coefs[2] + coefs[5]*d/M + coefs[6]/M + coefs[6]*d^2/M^2)
}

quadCATE(c(1,1,1), betas, lambda.est, psi.est, sigma.est, nu.est)
```

```{r}
dmvnorm(1, 2, matrix(.5, nrow = k))
```

