---
title: "est lavaan"
format: html
---

```{r}
library(lavaan)
```

```{r}
tag = "1D"
```

read data
```{r}
# Load data
# mydata <- read.csv("mydata.csv")
A = read.csv(paste("A_", tag, ".csv", sep = ""), header = FALSE)
Z = read.csv(paste("Z_", tag, ".csv", sep = ""), header = FALSE)
Y = read.csv(paste("Y_", tag, ".csv", sep = ""), header = FALSE)

mydata = Z
mydata$A = ordered(A$V1, levels = c(0, 1))
```

parameter recovery for factor probit model
```{r}
# Specify factor-probit regression model
model <- '
efa("efa1")*h1 + 
efa("efa1")*h2 =~ V1+V2+V3+V4+V5+V6

A ~ h1 + h2

A | 0*t1
'
model <- '
efa("efa1")*h1 =~ V1+V2+V3

A ~ h1
A ~ 1

A|0*t1

h1 ~ 0*1
'
fit <- sem(model, data=mydata, ordered = "A")
summary(fit, standardized=TRUE)
inspect(fit, "partable")
lambda.est = inspect(fit,what="est")$lambda[1:3,1]
psi.est = inspect(fit,what="est")$theta[1:3,1:3]
sigma.est = inspect(fit,what="est")$psi[1,1]
b.est = inspect(fit,what="est")$beta[2,1]
nu.est = inspect(fit,what="est")$nu[1:3,1]
alpha.est = inspect(fit,what="est")$alpha
tau.est = inspect(fit,what="est")$tau
delta.est = inspect(fit,what="est")$delta
```

expectations for functions of H given Z
```{r}
meanH = function(za, lambda, psi, sigma.est, b, alpha, nu){

  a = za[length(za)][1]
  z = t(za[1:length(za)-1])
  
  d = t(lambda) %*% solve(psi) %*% (z  - nu)
  M = t(lambda) %*% solve(psi) %*% lambda + 1/sigma.est
  constant1 = (b*d+M*alpha)/sqrt(M*(M+b^2))
  constant2 = b/sqrt(b^2*M+M^2)
  
  if (a == 1){
    return((constant2 * dnorm(constant1))/(pnorm(constant1))+d/M)
  }else if(a == 0){
    return((1/(1-pnorm(constant1)))*(constant2*dnorm(constant1)+d*pnorm(constant1)/M))
  }
}

# meanH(mydata[1,], lambda.est, psi.est, sigma.est, alpha.est[2], b.est)

varianceH = function(za, lambda, psi, sigma.est, nu, b, alpha){
  a = za[length(za)][1]
  z = t(za[1:length(za)-1])
  d = t(lambda) %*% solve(psi) %*% (z - nu)
  M = t(lambda) %*% solve(psi) %*% lambda + 1/sigma.est
  constant1 = (b*d+M*alpha)/sqrt(M*(M+b^2))
  constant2 = b/sqrt(b^2*M+M^2)
  
  if (a==1){
    ratio = dnorm(constant1)/pnorm(constant1)
    return(1/M-constant2*(constant1*ratio+ratio^2))
  }else if (a==0){
    Gx = pnorm(constant1)
    G.x = dnorm(constant1)
    difG.x = pnorm(constant1, lower.tail=FALSE)
    ratio = constant2^2
    return((1/difG.x^2)*((M+d^2)*Gx/M^2 + (b^3*d+2*b*d*M-alpha*b^2*M)*G.x/((b^2*M+M^2)^(3/2)) - ratio*G.x^2-(M+2*d^2)*Gx^2/M^2 - (3*b^3*d+4*b*d*M-b^2*alpha*M)*Gx*G.x/((b^2*M+M^2)^(3/2))))
  }
}
```

regression for betas
```{r}
expectations = c()
for(i in 1:nrow(mydata)) {
    row <- mydata[i,]
    expectations[i] = meanH(row, lambda.est, psi.est, sigma.est, alpha.est[2], b.est, nu.est)
}
```

```{r}
variances = c()

for(i in 1:nrow(mydata)) {
    row <- mydata[i,]
    variances[i] = varianceH(row, lambda.est, psi.est, sigma.est, nu.est, b.est, alpha.est[2])
}

mydata$expectations = expectations
mydata$Y = Y$V1
reg = lm(Y ~ A*expectations, mydata)
summary.lm(reg)

betas = coef(reg)
```

```{r}
linearCATE = function(z, coefs, lambda, psi, sigma.est, nu){
  d = t(lambda) %*% solve(psi) %*% (z - nu)
  M = t(lambda) %*% solve(psi) %*% lambda + 1/sigma.est
  return(coefs[4]*d/M + coefs[2])
}

linearCATE(c(1,1,1), betas, lambda.est, psi.est, sigma.est, nu.est)
```

```{r}
mydata$variances = variances
reg2 = lm(Y ~ A*expectations+A*variances, mydata)
summary.lm(reg2)

betas = coef(reg2)

quadCATE = function(z, coefs, lambda, psi, sigma.est, nu){
  d = t(lambda) %*% solve(psi) %*% (z - nu)
  M = t(lambda) %*% solve(psi) %*% lambda + 1/sigma.est
  
  return(coefs[1] + coefs[5]*d/M + coefs[6]/M + coefs[6]*d^2/M^2)
}

quadCATE(c(1,1,1), betas, lambda.est, psi.est, sigma.est, nu.est)
```

