---
title: "est lavaan"
format: html
---

```{r}
library(lavaan)
```

```{r}
tag = "1D"
```

read data
```{r}
# Load data
# mydata <- read.csv("mydata.csv")
A = read.csv(paste("A_", tag, ".csv", sep = ""), header = FALSE)
Z = read.csv(paste("Z_", tag, ".csv", sep = ""), header = FALSE)
Y = read.csv(paste("Y_", tag, ".csv", sep = ""), header = FALSE)

mydata = Z
mydata$A = ordered(A$V1, levels = c(0, 1))
```

parameter recovery for factor probit model
```{r}
# Specify factor-probit regression model
model <- '
efa("efa1")*h1 + 
efa("efa1")*h2 =~ V1+V2+V3+V4+V5+V6

A ~ h1 + h2

A | 0*t1
'
model <- '
efa("efa1")*h1 =~ V1+V2+V3

A ~ h1

A | 0*t1
'
fit <- sem(model, data=mydata, ordered = "A")
summary(fit, standardized=TRUE)
inspect(fit, "partable")
lambda.est = inspect(fit,what="est")$lambda[1:3,1]
psi.est = inspect(fit,what="est")$theta[1:3,1:3]
sigma.est = inspect(fit,what="est")$psi[1,1]
b.est = inspect(fit,what="est")$beta[2,1]
nu.est = inspect(fit,what="est")$nu
alpha.est = inspect(fit,what="est")$alpha
tau.est = inspect(fit,what="est")$tau
delta.est = inspect(fit,what="est")$delta
```
```{r}
mydata[1,]
```

expectations for functions of H given Z
```{r}
meanH = function(za, lambda, psi, sigma.est, mu, b){
  a = za[length(za)][1]
  z = t(za[1:length(za)-1])
  d = t(lambda) %*% solve(psi) %*% z + mu/sigma.est
  M = t(lambda) %*% solve(psi) %*% lambda + 1/sigma.est
  constant1 = b*d/sqrt(M*(M+b^2))
  
  if (a == 1){
    return((b*dnorm(constant1))/(sqrt((b^2+M)/M)*pnorm(constant1))+d/M)
  }else if(a == 0){
    return((1/(1-pnorm(constant1)))*(b*dnorm(constant1)/sqrt((b^2+M)/M)+d*pnorm(constant1)))
  }
}

# meanH(mydata[1,], lambda.est, psi.est, sigma.est, alpha.est[2], b.est)

varianceH = function(a, z, lambda, psi, sigma.est, mu, b){
  d = t(lambda) %*% solve(psi) %*% z + mu/sigma.est
  M = t(lambda) %*% solve(psi) %*% lambda + 1/sigma.est
  constant1 = b*d/sqrt(M*(M+b^2))
  
  if (a==1){
    ratio = dnorm(constant1)/pnorm(constant1)
    return(1/M+(b^2*(M-2)/(b^2+M))*ratio^2+4*constant1*ratio/M)
  }else if (a==0){
    Gx = pnorm(constant1)
    G.x = dnorm(constant1)
    difG.x = pnorm(constant1, lower.tail=FALSE)
    ratio = b^2/(b^2+M)
    return((M+d^2)*Gx/M^2-2*(d*Gx/(M*difG.x))^2+(d/M)^2*(Gx)^3/difG.x-2*constant1*(M-1)*Gx*G.x/(M*difG.x) + 2*constant1*G.x*(Gx)^2/difG.x + ratio*M*Gx*(G.x)^2/difG.x-2*ratio*(G.x)^2/difG.x + 2*constant*G.x/M)
  }
}
```

regression for betas
```{r}
expectations = c()
for(i in 1:nrow(mydata)) {
    row <- mydata[i,]
    expectations[i] = meanH(row, lambda.est, psi.est, sigma.est, alpha.est[2], b.est)
}

mydata$expectations = expectations
mydata$Y = Y$V1
reg = lm(Y ~ A*expectations, mydata)
summary.lm(reg)

betas = coef(reg)
```

```{r}
linearCATE = function(z, coefs, lambda, psi, sigma.est, mu){
  d = t(lambda) %*% solve(psi) %*% z + mu/sigma.est
  M = t(lambda) %*% solve(psi) %*% lambda + 1/sigma.est
  
  return(coefs[3]*d/M + coefs[2])
}

linearCATE(c(-1,.4,-.31), betas, lambda.est, psi.est, sigma.est, alpha.est[2])
```

